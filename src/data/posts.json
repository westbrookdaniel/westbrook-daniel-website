[{"id":"audit-react-performance","info":{"title":"Auditing React Performance","description":"How to use the React DevTools Profiler","date":1653045254642,"snippet":"Finding what's making your react app slow can be hard, but hopefully, I can give provide some tools and places you can look to improve your performance with less hassle. There are three main tools I always use when debugging performance..."},"html":"<p>Finding what's making your react app slow can be hard, but hopefully, I can give provide\nsome tools and places you can look to improve your performance with less hassle. There\nare three main tools I always use when debugging performance:</p>\n<ul>\n<li>React DevTools Profiler</li>\n<li>Chrome DevTools Performance Panel</li>\n<li>Lighthouse</li>\n</ul>\n<p>Each are great at providing solving different problems - this post\ncovers how to use the React DevTools Profiler.</p>\n<p>You probably already have the React DevTools installed, but if you don't you can\ninstall it from the <a href=\"https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en\">chrome web store</a>.\nNow you have Chrome DevTools installed let's get stuck into an example from my website.</p>\n<h2>Ranked Chart</h2>\n<p><img src=\"/images/blog/audit-react-performance/profiler.png\" alt=\"Profiler Ranked Chart\"></p>\n<p>In the profiler, you can go through each render by using the arrows in the top right\n(where it says 2 / 5). This particular view is called the Ranked chart.\nHere I was looking at how changing pages are rendered for me, and I can use this view\nto see what took the longest to render. I find the Ranked chart the most useful in\nbloated components since it shows the components that took the longest to render at the top.</p>\n<h2>Flamegraph Chart</h2>\n<p>The other view for a recording I use is the flamegraph:</p>\n<p><img src=\"/images/blog/audit-react-performance/flamechart.png\" alt=\"Profiler Flamegraph Chart\"></p>\n<p>This shows the components in the order they were nested (for example <code>ProjectItems</code>\ncontains <code>Items</code>). What's useful about this view is it will gray out components that have skipped\nrerendering, so you can identify which component is causing large sections of your app to\nrerender, which can be harmful to performance if it happens frequently.</p>\n<p>A common cause of this to watch out for is the <a href=\"https://reactjs.org/docs/context.html\">Context API</a>.\nIf your context is updating frequently then you should probably just pass the state as props,\nor use <a href=\"https://github.com/pmndrs/zustand\">zustand</a> (or even\n<a href=\"https://github.com/pmndrs/zustand#react-context\">zustand/context</a>).</p>\n<p>You can also use the <code>Highlight updates when components rerender</code> option in the React DevTools\nsettings to get a similar more visual version of this.</p>\n<h2>What did you think?</h2>\n<p>Whilst the profiler can be very useful for tracking down what components are causing you\ntrouble rendering, but sometimes your issue isn't to do with rendering. Some of the other tools mentioned\ncan be better at solving those problems. If there was something you think I missed, let me know!</p>"},{"id":"client-file-based-router","info":{"title":"Client Side File-Based Router","description":"See how you can use a file-based router in your client side projects","date":1627804215996,"snippet":"Nextjs and other server-side frameworks have a great feature that makes adding new pages in your web app very continent, referred to as a file-based router. Usually, within a `pages` folder..."},"html":"<p>Nextjs and other server-side frameworks have a great feature that makes adding new pages in your web app very continent, referred to as a file-based router. Usually, within a <code>pages</code> folder, you can add React component files and they will automatically be converted into routes in your app, with features like dynamic routes and 404 pages still working based on the name of the file.</p>\n<pre><code class=\"language-jsx\">// pages/about.js\nconst About = () => {\n\treturn &#x3C;h1>About Page&#x3C;/div>\n}\n// pages/index.js\nconst Home = () => {\n\treturn &#x3C;h1>Home Page&#x3C;/div>\n}\n</code></pre>\n<p>In this example, <code>pages/index.js</code> would be rendered for route <code>/</code> and <code>pages/about.js</code> for the route <code>/about</code>.</p>\n<h2>Glob Magic</h2>\n<p>What if I told you that you didn't need a server-side application to pull this off thanks to the power of tools like Vite and Webpack. Both of these contain a method of importing all of the files from the directory in the form of <a href=\"https://vitejs.dev/guide/features.html#glob-import\">Vite's glob imports</a> and Webpack Context API (not to be confused with <a href=\"https://reactjs.org/docs/context.html\">React's context API</a>).</p>\n<p>To save you time, I've created an example project that utilities Vite's glob import to have a file-based router that not only provides the complete routing capabilities of <code>react-router-dom</code>, but also provides more benefits.</p>\n<h2>Improvements</h2>\n<p>The quality of life improvements I've included in this project are:</p>\n<ul>\n<li>Ignoring inline test files</li>\n<li>Pages being able to provide information to the router</li>\n<li>Being able to easily wrap every route</li>\n</ul>\n<p>In the past, I've found one of the biggest problems with file-based routers is the difficulty in testing. Many (like Nextjs) don't ignore tests sitting alongside routes which makes it difficult to maintain a consistent place to put test files. By changing the glob to ignore test files I was able to make this minor quality of life improvement.</p>\n<p>Data can be provided back to the router via a <code>RouteData</code> export like this:</p>\n<pre><code class=\"language-jsx\">export const data = {\n    name: 'Home',\n    handlesOwnRouting: true,\n}\n</code></pre>\n<p>Since you can import a list of all routes, this can be useful for providing names to important routes for use in analytic or automatically generated navigation. One other property I have implemented is <code>handlesOwnRouting</code> which allows a component to provide its own routing without being directed to the 404 route.</p>\n<p>As for wrapping every route, it might not initially seem useful since you could just wrap the router itself, but since we're providing a lot of useful information about the route itself it is the perfect place for authentication based route protection to be added.</p>\n<h2>Try it Out</h2>\n<p>Do you like or have you ever used file-based routers? You're welcome to give mine a try by visiting the repository <a href=\"https://github.com/westbrookdaniel/file-based-router-example\">file-based-router-example</a>. If you want to see me convert this into an NPM package or share the Webpack based example you can contact me through Twitter or email.</p>"},{"id":"nextjs-10-1-update","info":{"title":"Nextjs 10.1 Development Improvements","description":"Learn about the latest updates to next/image and other improvements","date":1618650842693,"snippet":"Nextjs just got it's most recent update - 10.1 - which brings a lot of new exciting features. Some highlights include: 3x faster refresh, Reduced install time/size, next/image Improvements, Custom 500 page, Initial Webpack 5 support."},"html":"<p>Nextjs just got its most recent update - 10.1 - which brings a lot of new exciting features. Some highlights include:</p>\n<ul>\n<li>3x faster refresh</li>\n<li>Reduced install time/size</li>\n<li><code>next/image</code> Improvements</li>\n<li>Custom 500 page</li>\n<li>Initial Webpack 5 support</li>\n</ul>\n<p>I want to go deeper into the changes to <code>next/image</code> because I think these\nimprovements do a great job at improving the development experience of Nextjs.</p>\n<h2>What is <code>next/image</code>?</h2>\n<p>Introduced back in 10.0, <code>next/image</code> is a \"drop-in replacement\" for the img tag (except width and height are now required).</p>\n<pre><code class=\"language-jsx\">import Image from 'next/image'\n\n&#x3C;Image src=\"/profile-picture.jpg\" width=\"400\" height=\"400\" alt=\"Profile Picture\">\n</code></pre>\n<p>It provides automatic image optimization through resizing, reducing quality, lazy loading, and changing file format. It also can do this based on your device\nscreen size to serve smaller images for mobile. This is all done automatically with Vercel, or you can provide your own <a href=\"https://nextjs.org/docs/api-reference/next/image#loader\">custom loaders</a>.</p>\n<h2>Now in built in WebAssembly</h2>\n<p>To get <code>next/image</code> working, it used to use a native dependency which leads to a big\ninstall size, almost 50% being just native dependencies. With 10.1, Nextjs now uses WebAssembly\nfor this, reducing install size by ~30MB as well as adding support for Apple Silicon M1 MacBooks.\nThere are even more improvements possible in the future because of this move thanks to SIMD extensions and multi-threading.</p>\n<h2>Did I mention development is faster?</h2>\n<p>Previously the development flow in Nextjs using <code>next/image</code> would go like this; add your big high-resolution\nimage to your repo and use it. In production, this would automatically get optimised, <em>but</em> locally when using\n<code>next dev</code> and <code>next start</code> these optimisations wouldn't be applied, leaving your browser\nto struggle to load 10mb's of unoptimised images which would normally be handled perfectly in production.</p>\n<p>Now, could I have just optimised my images like everyone else? I say where's the fun in that!\nBut thanks to the move to WebAssembly we are now able to get these optimisations when using <code>next dev</code>\nand <code>next start</code> locally.</p>\n<p>Between this improvement, 3x faster refreshing, and speed increases when using Webpack 5,\nthis update has been an awesome look at the direction Nextjs is heading.</p>\n<p>You can see more in <a href=\"https://nextjs.org/blog/next-10-1\">Nextjs' blog post</a></p>"},{"id":"react-abort-controllers","info":{"title":"Using AbortControllers to Cancel Fetch in React","description":"How to use the web api to cancel fetch easily","date":1618230568834,"snippet":"In react we can use fetch in a useEffect to get a request when the page loads... This uses the web api AbortController as the signal for fetch. By returning a function from useEffect we can trigger the abort controller on dismount..."},"html":"<p>In React we can use fetch in a <code>useEffect</code> hook to make a request when the page loads. So why is the code below problematic?</p>\n<pre><code class=\"language-jsx\">const Example = () => {\n    useEffect(() => {\n        fetch('https://jsonplaceholder.typicode.com/posts/1')\n            .then(res => res.json())\n            .then(json => setMessage(json.title))\n            .catch(error => console.error(error.message))\n    }, [])\n    return &#x3C;div>{message}&#x3C;/div>\n}\n</code></pre>\n<p>If we unmount the component while this fetch is in process we will get the following error.</p>\n<pre><code class=\"language-md\">Warning: Can't perform a React state update on an unmounted component.\nThis is a no-op, but it indicates a memory leak in your application.\nTo fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount\nmethod.\n</code></pre>\n<p>What does this mean? <code>update on an unmounted component</code> summarizes it well. We are trying to change\nthe state of a component that no longer exists, because it was removed. This can lead to our app\nbreaking in weird ways, as well as wasting resources on unnecessary actions.\nSo let's fix it by canceling the fetch.</p>\n<pre><code class=\"language-jsx\">useEffect(() => {\n    const controller = new AbortController()\n\n    fetch('https://jsonplaceholder.typicode.com/posts/1', {\n        signal: controller.signal,\n    })\n        .then(res => res.json())\n        .then(json => setMessage(json.title))\n        .catch(error => console.error(error.message))\n\n    return () => controller.abort()\n}, [])\n</code></pre>\n<p>Here we use the web api <code>AbortController</code> as the signal for fetch. By returning a function from <code>useEffect</code> we\ncan trigger the abort controller on dismount (see the React <a href=\"https://reactjs.org/docs/hooks-effect.html#example-using-hooks-1\">docs</a>).\nThe <code>AbortSignal</code> (<code>controller.signal</code>) is then passed into the fetch as an argument and voilà!</p>\n<p>Although, there is a problem with this solution. When the component is unmounted while a fetch call is in progress, this\nmessage is logged to the console:</p>\n<pre><code class=\"language-md\">The user aborted a request.\n</code></pre>\n<p>This happens because aborting the fetch doesn't magically delete the promise, so it fails with an\n<code>AbortError</code> which is getting logged in <code>catch</code>.</p>\n<pre><code class=\"language-jsx\">useEffect(() => {\n    const controller = new AbortController()\n\n    fetch('https://jsonplaceholder.typicode.com/posts/1', {\n        signal: controller.signal,\n    })\n        .then(res => res.json())\n        .then(json => setMessage(json.title))\n        .catch(error => {\n            if (error.name !== 'AbortError') {\n                console.error(error.message)\n            }\n        })\n\n    return () => controller.abort()\n}, [])\n</code></pre>\n<p>By ignoring the error if it has the name <code>AbortError</code>, we've solved the problem! You can read\nmore about <code>AbortController</code> on <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/AbortController\">MDN</a>.\nYou can also see its browser support on <a href=\"https://caniuse.com/abortcontroller\">caniuse</a>.</p>\n<p>Jumping back to the code, this request this still doesn't expose a loading state or indicate to the ui if it has failed.\nIf you don't want to deal with all of this, you're probably better off just using\n<a href=\"https://react-query.tanstack.com/\"><code>react-query</code></a> instead (which also does it in a lot less code).</p>\n<pre><code class=\"language-jsx\">const { data, isLoading /* etc... */ } = useQuery('title', () =>\n    fetch('https://jsonplaceholder.typicode.com/posts/1')\n        .then(res => res.json())\n        .then(res => res.title)\n)\n</code></pre>\n<p>How much easier is that! You can find an example of all of these methods implemented on\n<a href=\"https://codesandbox.io/s/mutable-pine-psldb?file=/src/Comp.js\">CodeSandbox</a>.</p>"},{"id":"start-any-project-with-vite","info":{"title":"Start Any Project With Vite","description":"Explore a new, fast, and easy to use build tool","date":1624016139854,"snippet":"Recently I've been using Vite (pronounced /vit/) when starting up my new projects, specifically Vite 2.0. Vite is a easy to use build tool like Create React App but supports many libraries and frameworks, with the below templates in Javascript and Typescript..."},"html":"<p>Recently I've been using Vite (pronounced <code>/vit/</code>) when starting up my new projects,\nspecifically Vite 2.0. Vite is an easy to use build tool like Create React App but\nsupports many libraries and frameworks, with the below templates in Javascript and\nTypescript:</p>\n<ul>\n<li>Vanilla</li>\n<li>Vue</li>\n<li>React</li>\n<li>Preact</li>\n<li>Lit-element</li>\n<li>Svelte</li>\n</ul>\n<h2>Development</h2>\n<p>It provides a much faster local development experience as usual, due to its utilisation of native ES modules\nand <a href=\"https://esbuild.github.io/\">esbuild</a>. Esbuild is an extremely fast bundler written in Go which is 10-100x\nfaster than other bundlers. This leads to a start-up time of 100ms and hot module reloading of under 50ms. Vite\nalso supports React's fast refresh through its plugin system via <a href=\"https://github.com/vitejs/vite/tree/main/packages/plugin-legacy\"><code>@vitejs/plugin-react-refresh</code></a>.</p>\n<h2>It's All Supported</h2>\n<p>Typescript (<code>.ts</code> and <code>.tsx</code>) files are also supported out of the box with no configuration. The only caveat\nbeing JSX can only be used in <code>.tsx</code> and <code>.jsx</code> files - not <code>.js</code> out of the box. So are CSS Modules by just\nimporting a <code>.module.css</code> file, and image files of course. All you need to do to get CSS Pre-processors like\nSass and Less working is to install the packages::</p>\n<pre><code class=\"language-bash\"># .scss and .sass\nnpm install -D sass\n\n# .less\nnpm install -D less\n</code></pre>\n<p>It even supports the loading of Web Workers and Web Assembly out of the box:</p>\n<pre><code class=\"language-js\">// Web Workers\nimport Worker from './worker.js?worker'\n\nconst worker = new MyWorker()\n\n// Web Assembly\nimport init from './example.wasm'\n\ninit().then(exports => {\n    exports.test()\n})\n</code></pre>\n<p>If you want to learn more about what's supported, checkout <a href=\"https://vitejs.dev/guide/\">Vite's guide</a>.</p>\n<h2>Production</h2>\n<p>In production, Vite uses pre-configured Rollup which uses native ESModules. Although, if you want to support\nolder browsers like IE11 you can do so by just including the official\n<a href=\"https://github.com/vitejs/vite/tree/main/packages/plugin-legacy\"><code>@vitejs/plugin-legacy</code></a>. This plugin also\nincludes these polyfills if the browser requires them, allowing everyone to get the best experience regardless of the platform.</p>\n<h2>Easy to Use</h2>\n<p>Most importantly, Vite is quick to set up and use with everything just working. Because of how fast local\ndevelopment is, I have found it to be a lot quicker (and more fun) to try out a new package in Vite when\ncompared to Create React App, or even Nextjs when its features aren't needed.</p>\n<p>If you want to try it out you can get started with the CLI by typing <code>npm init @vitejs/app</code> or\n<code>yarn create @vitejs/app</code>, and be sure to let me know what you think.</p>"},{"id":"tailwindcss-jit","info":{"title":"Compile CSS classes on demand with Tailwind CSS JIT mode","description":"The new on demand compiler for Tailwind CSS","date":1619400842151,"snippet":"Recently Tailwind CSS has added an experimental new compiler that you can use to generate its classes. If you aren't familiar with how Tailwind works traditionally, here's the summary; based on the options you provide in a tailwind.config.js file, on build time..."},"html":"<p>Recently Tailwind CSS has added an experimental new compiler that you can use to generate its classes.\nIf you aren't familiar with how Tailwind works traditionally, here's the summary; based on the options you provide\nin a <code>tailwind.config.js</code> file, on build time Tailwind will create all the necessary classes for your code. Then, when\nbuilding for production, it will remove any unused classes with <a href=\"https://purgecss.com/\">PurgeCSS</a>.</p>\n<p>The new Just-In-Time mode now uses this same method to create instead of remove classes. This has amazing benefits\nfor Tailwind like a reduced build time in development and production, as well as allowing for the stacking of variants. Althoughm I think a more interesting usage\nis the creation of arbitrary classes. Let's go through an example of where this would be\nuseful.</p>\n<p>Say I'm creating a series of social media icons on my website using SVGs, where I want each icon to be its brand colours.\nThere's a couple of ways this could be done normally. <em>(I'll be using React for this example but the same applies to HTML or any other framework)</em></p>\n<p>You could use inline styles:</p>\n<pre><code class=\"language-jsx\">&#x3C;Twitter style={{ color: '#00acee' }} />\n</code></pre>\n<p>Or an external stylesheet:</p>\n<pre><code class=\"language-css\">/* styles.css */\n.twitter-color {\n    color: #00acee;\n}\n</code></pre>\n<pre><code class=\"language-jsx\">&#x3C;Twitter className=\"twitter-color\" />\n</code></pre>\n<p>Or you could even add the colour to your Tailwind theme:</p>\n<pre><code class=\"language-js\">// tailwind.config.js\nmodule.exports = {\n    /* ... */\n    colors: {\n        twitter: '#00acee',\n    },\n    /* ... */\n}\n</code></pre>\n<pre><code class=\"language-jsx\">&#x3C;Twitter className=\"text-twitter\" />\n</code></pre>\n<p>While these solutions work, they're not ideal. There may be other circumstances in your\ncode where you might need to position a background image or set the height of navigation, and writing\na precise pixel value in your usual Tailwind styles would be the easiest way.</p>\n<p>That's where Just-In-Time mode comes in:</p>\n<pre><code class=\"language-jsx\">&#x3C;Twitter className=\"text-[#00acee]\" />\n</code></pre>\n<p>By putting any value in square brackets, the just in time compiler will create a new class on the fly\nusing this value. To use it you need to be using Tailwind CSS 2.1 or later and then you\ncan add <code>mode: 'jit'</code> to your config file, as well as ensuring you have the <code>purge</code> option setup.</p>\n<p>You can read more about this feature in <a href=\"https://tailwindcss.com/docs/just-in-time-mode#enabling-jit-mode\">Tailwind's documentation</a>.</p>"},{"id":"valtio-brings-vue-to-react","info":{"title":"Valtio Brings Vue's State to React","description":"Be more flexible about where you use state","date":1634347371335,"snippet":"What's great about Vue is that it has a very simple way to manage state. One of the best things about Vue's state is it doesn't have the same restrictions as hooks. For example, the below code is invalid in React because hooks must be used..."},"html":"<p>What's great about Vue is that it has a very simple way to manage state. One of the best things about Vue's\nstate is it doesn't have the same restrictions as hooks. For example, the below code is invalid in\nReact because hooks must be used inside of a functional component.</p>\n<pre><code class=\"language-jsx\">const [count, setCount] = useState(0)\n\nexport default function Component() {\n    return &#x3C;div>{count}&#x3C;/div>\n}\n</code></pre>\n<p>In Vue, you don't need to worry about where you create refs, you even import one from another file\nand Vue won't care.</p>\n<pre><code class=\"language-js\">const count = ref(0)\n</code></pre>\n<p>In React, you generally want to use\n<a href=\"https://reactjs.org/docs/composition-vs-inheritance.html\">component composition</a> first to avoid\nthe above problem. Although, this can not always be avoided. The default way of solving this is <code>useContext</code>.\nThis is an example from the <a href=\"https://reactjs.org/docs/hooks-reference.html#usecontext\">react docs</a>\non how to use context:</p>\n<pre><code class=\"language-jsx\">const themes = {\n    light: {\n        foreground: '#000000',\n        background: '#eeeeee',\n    },\n    dark: {\n        foreground: '#ffffff',\n        background: '#222222',\n    },\n}\n\nconst ThemeContext = React.createContext(themes.light)\n\nfunction App() {\n    return (\n        &#x3C;ThemeContext.Provider value={themes.dark}>\n            &#x3C;Toolbar />\n        &#x3C;/ThemeContext.Provider>\n    )\n}\n\nfunction Toolbar(props) {\n    return (\n        &#x3C;div>\n            &#x3C;ThemedButton />\n        &#x3C;/div>\n    )\n}\n\nfunction ThemedButton() {\n    const theme = useContext(ThemeContext)\n    return (\n        &#x3C;button\n            style={{ background: theme.background, color: theme.foreground }}\n        >\n            I am styled by theme context!\n        &#x3C;/button>\n    )\n}\n</code></pre>\n<p>And here is the same example but with Valtio, a new state management tool from pmndrs:</p>\n<pre><code class=\"language-jsx\">const themes = {\n    light: {\n        foreground: '#000000',\n        background: '#eeeeee',\n    },\n    dark: {\n        foreground: '#ffffff',\n        background: '#222222',\n    },\n}\n\nconst theme = proxy(themes.dark)\n\nfunction App() {\n    return &#x3C;Toolbar />\n}\n\nfunction Toolbar(props) {\n    return (\n        &#x3C;div>\n            &#x3C;ThemedButton />\n        &#x3C;/div>\n    )\n}\n\nfunction ThemedButton() {\n    const snap = useSnapshot(theme)\n    return (\n        &#x3C;button style={{ background: snap.background, color: snap.foreground }}>\n            I am styled by theme context!\n        &#x3C;/button>\n    )\n}\n</code></pre>\n<p>Valtio gives us some tools to manage state in ways similar to Vue. In the example above, we create\nstate through the use of <code>proxy</code> and then access it on our component with <code>useSnapshot</code>. You'll notice\nthat there is no need to wrap our component in a <code>ThemeContext.Provider</code>, everything just works.</p>\n<p>You may be wondering how you would go about changing the theme in this example. This is where Valtio shines,\nbecause it allows you make any changes (including mutations) just like you would in vanilla javascript.</p>\n<pre><code class=\"language-jsx\">const theme = proxy(themes.dark)\n\nfunction setLightTheme() {\n    theme.background = themes.light.background\n    theme.foreground = themes.light.foreground\n}\n</code></pre>\n<p>Or simplified further when taking into account that Valtio only updates your React component\nwhen <em>only the state you accessed changes</em>. We can utilize this to simplify the code for updating the theme,\nwithout having to worry about the impact of extra re-renders.</p>\n<pre><code class=\"language-jsx\">const theme = proxy({\n    ...themes,\n    current: themes.dark,\n})\n\nfunction setLightTheme() {\n    theme.current = theme.light\n}\n</code></pre>\n<p>The flexibility of Valtio makes it very useful, but it's important to note that Valtio is not a replacement for\n<code>useState</code>. This is only necessary for state that is shared across components. I would recommend you\nvisit <a href=\"https://github.com/pmndrs/valtio\">Valtio's Github Page</a> to see all the features of Valtio and check out\nthe other awesome packages from pmndrs like <a href=\"https://github.com/pmndrs/react-three-fiber\">react-three-fibre</a>. If you've used Valtio before, I would love to know what your experiences are and if you'd recommend it.</p>"},{"id":"website-upgrade","info":{"title":"Time for a Website Upgrade","description":"Adding theming and improving performance","date":1623930322525,"snippet":"With the release of Nextjs 11, I decided it was time for some website improvements. Some of the key problems I wanted to solve was...Thankfully, these first two are made easy by Nextjs 11. The recent placeholder property added to the next/image component..."},"html":"<p>With the release of Nextjs 11, I decided it was time for some website improvements.\nSome of the key problems I wanted to solve was:</p>\n<ul>\n<li>Initial image loading</li>\n<li>Better development linting</li>\n<li>Dark mode (very exciting)</li>\n</ul>\n<h2>Nextjs to the Rescue</h2>\n<p>Thankfully, these first two are made easy by Nextjs 11. The recent <code>placeholder</code> property\nadded to the <code>next/image</code> component allows for the easy generating of blur effects on the\ninitial load of images. Check out more about the feature in their <a href=\"https://nextjs.org/blog/next-11#image-placeholders\">blog post</a>.</p>\n<p>Nextjs also added ESLint support with great defaults and performance-related linting.\nIt's easy to get started by running <code>npx next lint</code> which configures ESLint and lets you know\nwhat you need to fix. This is included as a part of <a href=\"https://nextjs.org/blog/next-11#conformance\">Conformance for Nextjs</a>\nwhich looks like a great direction for the future of the framework.</p>\n<h2>Theming!</h2>\n<p>I originally wanted to just achieve a dark mode option for my website, but I decided\nI wanted to make more colour schemes avalible whilst still having an automatic colour switcher.\nMy inspiration originally came from the <a href=\"https://rebassjs.org/\">Rebass website</a> pictured below which\nhas a similar colour scheme switcher.</p>\n<p><img src=\"/images/blog/website-upgrade/rebassjs.png\" alt=\"Rebase Website\"></p>\n<p>The styling of my website is done with <a href=\"https://tailwindcss.com/\">TailwindCSS</a>, and since it supports using CSS custom properties, that\nwas where I started my implementation.</p>\n<p>I used the strategy of creating a ThemeHandler to consume a theme from local storage, and a piece of global state\nprovided by <a href=\"https://github.com/pmndrs/zustand\">zustand</a>.</p>\n<pre><code class=\"language-tsx\">export const useTheme = create&#x3C;ThemeStore>((set, get) => ({\n    theme:\n        getLocalStorage('theme') ||\n        (typeof window !== 'undefined'\n            ? window.matchMedia('(prefers-color-scheme: dark)').matches\n                ? 'dark'\n                : 'light'\n            : 'light'),\n    updateTheme: theme => {\n        setLocalStorage('theme', theme)\n        set({ theme })\n    },\n    rotateTheme: () =>\n        set(s => {\n            const keys = Object.keys(themes)\n            const i = keys.indexOf(s.theme)\n            const newTheme = (\n                keys.length - 1 > i ? keys[i + 1] : keys[0]\n            ) as keyof typeof themes\n            setLocalStorage('theme', newTheme)\n            return { theme: newTheme }\n        }),\n}))\n</code></pre>\n<p>Because this is outside of a component and Nextjs code is run on the server, I do need to make sure that\nthe window exists before checking if dark mode is active using <code>window.matchMedia('(prefers-color-scheme: dark)').matches</code>. Next, I\nneeded to attach some CSS variables to the root of the document for the initial load of the website,\nand a set of themes to consume later.</p>\n<pre><code class=\"language-css\">:root {\n    --brand: #d43c29;\n    --on-brand: #ffffff;\n\n    --accent: #6f5623;\n    --accent-hover: #846929;\n    --accent-focus: #9a7c2e;\n    --on-accent: #ffffff;\n\n    --background: #ffffff;\n    --on-background: #4d5c63;\n    --heading-on-background: #000;\n\n    /* ... */\n}\n</code></pre>\n<pre><code class=\"language-tsx\">export const themes = {\n    light: {\n        brand: '#d43c29',\n        /* ... */\n    },\n    dark: {\n        brand: '#e36552',\n        /* ... */\n    },\n}\n</code></pre>\n<p>Now we get to the fun stuff - actually changing the colour scheme. This is done in a <code>useEffect</code> hook\nso we can only change the theme only when we need to. By attaching an event listener for <code>change</code>\nto <code>window.matchMedia('(prefers-color-scheme: dark)')</code> we can update the theme automatically if the user\nturns on their computers dark mode.</p>\n<p>We can then use our theme object to get the set of colours we need to apply and utilise <code>/*...*/ style.setProperty(`--${key}`, value)</code>\nto update the colour scheme. You can find below some more of the code I used for changing and handling the theme.</p>\n<pre><code class=\"language-tsx\">const theme = useTheme(s => s.theme)\nconst updateTheme = useTheme(s => s.updateTheme)\n\n/* ... */\n\nuseEffect(() => {\n    if (!document.documentElement) return\n\n    window\n        .matchMedia('(prefers-color-scheme: dark)')\n        .addEventListener('change', e => {\n            if (e.matches) {\n                updateTheme('dark')\n            } else {\n                updateTheme('light')\n            }\n        })\n\n    const currentTheme = themes[theme]\n\n    Object.keys(currentTheme).forEach(key => {\n        const value = currentTheme[key as keyof typeof currentTheme]\n        document.documentElement.style.setProperty(`--${key}`, value)\n    })\n}, [theme, updateTheme])\n</code></pre>\n<h2>The Future</h2>\n<p>It was a lot of fun doing this performance refresh. Keep your eye out\nfor more themes coming in the future. Some features I may look at adding next\nalong these lines are a theme picker for code blocks and more development tooling to\nhelp create more performant images.</p>"}]